<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[otto destrukt]]></title>
  <link href="http://blog.ottodestrukt.org/atom.xml" rel="self"/>
  <link href="http://blog.ottodestrukt.org/"/>
  <updated>2012-05-30T19:14:43-04:00</updated>
  <id>http://blog.ottodestrukt.org/</id>
  <author>
    <name><![CDATA[Alan Kligman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[gladius 0.1]]></title>
    <link href="http://blog.ottodestrukt.org/blog/2012/04/18/gladius-0-dot-1/"/>
    <updated>2012-04-18T11:17:00-04:00</updated>
    <id>http://blog.ottodestrukt.org/blog/2012/04/18/gladius-0-dot-1</id>
    <content type="html"><![CDATA[<p>Last week we released an early prototype of our 3D game engine. The engine is pure HTML5/JS and is designed to run client-side in the browser. Right now we&#8217;re focusing our test efforts in Firefox and Chrome, but the engine should run well in other standards-compliant browsers that support WebGL.</p>

<!-- more -->


<p>So, what can the prototype do? Right now the engine provides</p>

<ul>
<li>a game loop</li>
<li>resource loading</li>
<li>an entity/component framework</li>
<li>a 3D renderer (CubicVR)</li>
<li>a 2D physics engine (Box2D)</li>
<li>a bunch of unit tests and examples</li>
</ul>


<p>Modularity is a strong design goal and we use require.js to keep the source code in small files that define reusable modules.</p>

<h3>demo</h3>

<p><img class="center" src="http://blog.ottodestrukt.org/images/no-comply.png" width="370" height="280" title="no comply demo" alt="[ image: no comply demo ]"></p>

<p>Earlier this year we started collaborating with Andor Salga to build a demo game on our prototype engine. The demo shows off some of what the engine can do right now, but it&#8217;s also been very helpful in testing out some of our APIs. It&#8217;s also helping us collect some early performance feedback from the platform and identify <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=744546">issues</a>.</p>

<h3>what&#8217;s next</h3>

<p>You probably noticed that there are some important features still missing from the engine, like sound support. In the coming weeks I&#8217;ll be working on a cross-platform sound extension for the engine. Input also needs work. Right now there&#8217;s keyboard support but it&#8217;s difficult to use. I plan to add support for input maps and stateful event handling to make it easier for game logic to react to state changes. Finally, I&#8217;m working on some refactoring in the engine core to clarify some key abstractions and to break code apart so that it&#8217;s more reusable and easier to unit test.</p>

<p>There are a few infrastructure changes coming as well. Dan Mosedale prepared a pre-commit hook that runs our unit tests. We&#8217;re also updating a bunch of programs in our toolchain to newer versions. And if we have time this quarter, we&#8217;ll be refactoring our unit test suite to use require.js so that we can test our source modules in isolation.</p>

<p>For more information about Gladius, check out our <a href="https://github.com/gladiusjs/gladius-core">git repository</a> and our <a href="https://mozillalabs.com/en-US/gladius/">project page</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[data-driven game update loop]]></title>
    <link href="http://blog.ottodestrukt.org/blog/2011/12/14/data-driven-game-update-loop/"/>
    <updated>2011-12-14T19:16:00-05:00</updated>
    <id>http://blog.ottodestrukt.org/blog/2011/12/14/data-driven-game-update-loop</id>
    <content type="html"><![CDATA[<p>I&#8217;ve been refactoring the scheduler again to make it more data-driven. The previous incarnation provided priority-based scheduling, but that leaves it to the game developer to make sure that task priorities are correct, even for tasks that she didn&#8217;t write herself. The first change I made was to add scheduler phases. Right now there are three, named <em>Input</em>, <em>Update</em> and <em>Render</em>. The input and render phases shouldn&#8217;t result in any changes to game simulation state.</p>

<!-- more -->


<p><img class="center" src="http://blog.ottodestrukt.org/images/gladius-update-loop.svg" width="300" height="400" title="engine update loop" alt="[ image: engine update loop ]"></p>

<p>The second change I made was to add task groups to help capture different stages in each phase. For example, there are default groups for <em>Physics</em>, <em>Animation</em> and <em>Logic</em>, as well as others. A new task can specify a list of groups as dependencies during creation, and the scheduler will make sure that the new task runs only after each of its dependencies has finished. Creating a new task looks like this:</p>

<pre><code>var t = new engine.scheduler.Task({
    schedule: {
        phase: 'Update',
        depends: ['Physics'],
        interval: 100
    },
    group: 'Animation',
    callback: function() {
        ...
    }
});
</code></pre>

<p>This creates an Animation task that is scheduled after all Physics tasks, and runs every 100 ms in the Update phase. Because this task is in the Animation group, any other tasks that depend on Animation will be scheduled to run after this task. This is much cooler than a hard-coded game update loop because it&#8217;s not necessary to modify engine code to add new services to your game, only the schedule you pass in when you create your task.</p>

<p>(Thanks <a href="https://twitter.com/#!/secretrobotron">@secretrobotron</a> for the pretty image!)</p>
]]></content>
  </entry>
  
</feed>
